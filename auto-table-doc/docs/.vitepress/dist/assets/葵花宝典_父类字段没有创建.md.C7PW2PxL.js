import{_ as a,c as e,o as t,a4 as r}from"./chunks/framework.BcEugKYC.js";const f=JSON.parse('{"title":"常见问题","description":null,"frontmatter":{"title":"常见问题","description":null},"headers":[],"relativePath":"葵花宝典/父类字段没有创建.md","filePath":"葵花宝典/父类字段没有创建.md","lastUpdated":1731512067000}'),o={name:"葵花宝典/父类字段没有创建.md"},i=r('<h2 id="父类字段没有自动创建" tabindex="-1">父类字段没有自动创建 <a class="header-anchor" href="#父类字段没有自动创建" aria-label="Permalink to &quot;父类字段没有自动创建&quot;">​</a></h2><h3 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h3><p>子类继承了父类，但是父类中的字段没有在子类的表中自动创建列</p><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><p>最初对父类字段的处理方式是通过getDeclaredFields方法，获取了全部字段，仅剔除了static和final修饰的字段。</p><p>后续有小伙伴反馈，在使用部分框架（比如MybatisFlex）的时候，使用它的基类，会错误的将内部的私有字段在表中创建了列，不符合继承的原则。</p><p>所以，自<a href="/变更日志.html#_1-8-1">1.8.1</a>开始，修改了子类对父类字段的继承规则，仅支持public和protected修饰的字段，作为可被继承的字段。</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>自<a href="/变更日志.html#_1-8-4">1.8.4</a>开始，新增了一个<a href="/配置.html#strict-extends">strictExtends</a>配置开关，默认开启。</p><p>表示：子类继承父类的字段是否开启严格继承的模式（只继承public、protected修饰的字段）。</p>',10),l=[i];function s(_,c,n,d,h,p){return t(),e("div",null,l)}const m=a(o,[["render",s]]);export{f as __pageData,m as default};
